Ονοματεπώνυμο: Νικόλαος Μωυσάκης
Αριθμός μητρώου: 11152021001116


Για να δημιουργήσετε τα δύο εκτελέσιμα jobCommander και jobExecutorServer πρέπει να τρέξετε την εντολή 

make jobCommander jobExecutorServer

Τα εκτελέσιμα δημιουργούνται στον τρέχων φάκελο και τρέχουν χωρις ιδιαιτερότητες π.χ. ./jobCommander issueJob ls
Τα τεστ είναι όλα στον τρέχων φάκελο και τρέχουν χωρίς ιδιαιτερότητες π.χ. ./test_jobExecutor_1.sh
Για το progDelay παράγεται εκτελέσιμο με την εντολή make progDelay
Όλα τα τεστ επιστρέφουν την αναμενόμενη έξοδο.


Λίγα λόγια για το πρόγραμμα:
    Το βασικό πρόγραμμα είναι ο jobCommander (από αυτόν ξεκινάνε όλα). Αρχικά ελέγχει αν υπάρχει το αρχείο 
JobExecutorServer.txt που δημιουργεί o server και αν δεν υπάρχει τον δημιουργεί εκείνος κάνοντας fork() και exec().
Ο jobCommander και ο JobExecutorServer επικοινωνούν μεταξύ τους μέσω 2 named pipe που τα δημιουργεί ο JobCommander.
O λόγος που τα δημιουργεί εκείνος είναι διότι θέλουμε να τρέχουμε πολλαπλές εντολές του JobCommander ταυτόχρονα.
Τα named pipes αποθηκεύονται στον φάκελο tmp. Λόγω της ανάγκης για απεριόριστο μήκος input ο jobCommander
αρχικα περνάει στο pipe το μεγεθος του input και το παίρνει ο JobExecutorServer ωστέ να ξέρει τον αριθμό των bytes που θα 
διαβάσει. Υστέρα ο jobCommander γράφει στο pipe την εντολή και ο JobExecutorServer την διαβάζει. Με βάση αυτο που διάβασε
κάνει ορισμένες λειτουργίες. Μετα την λειτουργία ο JobExecutorServer μπαίνει σε πάυση μέχρι να στείλει σήμα (SIGUSR1) o
jobCommander για να ξαναξεκινήσει. Αν η εντολή που δωθεί είναι exit ο JobExecutorServer κλείνει και διαγράφεται το αρχείο.

Η ουρά:
    Η υλοποίηση της ουράς έχει τις βασικές της λειτουργίες όπως την αρχικοποίηση της,την εισαγωγή ενός στοιχείου, την συνά
ρτηση που επιστρέφει το μέγεθος της ουράς, την συνάρτηση διαγράφης της που στοχεύει στην απελευθέρωση την μνήμης ,
δύο συναρτήσεις εξαγωγής. Η μία είναι η κλασσική εξαγωγη απο το μπροστά άκρο της ουράς και η άλλη αφαιρεί ένα στοιχείο
από την ουρά με βάση το JobID σε οποιαδήποτε θέση και αν βρίσκεται.Ακόμα υπάρχειη διαγραφή ενός στοιχείου απο την ουρά με 
βάση το id που έχει στον ακέραιο chid της τριπλέτας. Υπάρχει επίσης η συνάρτηση που επιστρέφει 1 αν ένα στοιχείο είναι μέσα
στην ουρά και 0 αν δεν είναι.Τέλος υπάρχειμία συνάρτηση που βάζει όλες τις τριπλέτες της ουράς μέσα σε έναν πίνακα ο οπόιος
έχει περαστεί σαν όρισμα στην ουρα. Στη συνάρτηση εισαγωγής επιστρέφεται η θέση του στοιχείου στην ουρά. Αυτό εξυπηρέτει στην 
περίπτωση εισαγωγής διεργασίας (issueJob) που θα αναφέρουμε παρακάτω. 

Η δομή τριπλέτα διεργασίας:
    Η τριπλέτα διεργασίας περιέχει έναν ακέραιο που είναι η θέση στην ουρά. Έναν ακέραιο που έιναι το proccess ID της δι-
εργασίας που τρέχει(χρησιμοποιείται μόνο σε εν ενεργεία διεργασίες, δηλαδή μόνο στην ουρά queue_running). Τέλος περιέχει
δύο string ένα που έιναι το JobID της μορφής Job_XX και άλλο ένα που περιγράφει την διεργασία, π.χ ls -l.


JobCommander:
    Ο jobCommander αρχικά δέχεται ένα input απο το πληκτρολόγιο,στη συνέχεια δημιουργεί δύο named pipes στον φάκελο tmp.
Eλέγχει αν υπάεχει το αρχείο JobExecutorServer.txt και αν δεν υπάρχει τότε με fork() και exec() τρέχει τον server, αν δεν
είναι το παιδί proccess(που έχει καλέσει τον server) τότε συνδέονται τα pipes και περνάει το μέγεθος του μηνύματος μέσα
στο pipe ώστε να ξέρει ο JobExecutorServer πόσα byte να διαβάσει. Αφότου περαστεί το μέγεθος περνίεται και το input και
μεταφέρεται στον server. Στην περίπτωση που υπάρχει το αρχείο JobExecutorServer.txt τότε γίνεται η παραπάνω διαδικασία με
τα pipes απλά ο ο JobCommander στέλνει ένα σήμα στον JobExecutorServer (βρίσκει το pid του server μέσα στο αρχείο) ωστέ
να ξυπνήσει απο το pause() που έχει μπει και να ξαναδιαβάσει απο το pipe.




JobExecutorServer:
    Ο JobExecutorServer δημιουργεί ένα αρχείο και βάζει μέσα το proccess id του. Στη συνέχεια ανοίγει τα pipe και
συνδέεται με τον JobCommander. Ακολουθεί ένα while loop που δέν τερματιζεί μέχρι να περάσει ο jobCommander την εντολή
exit. Σε κάθε επανάληψη ο JobExecutorServer μπαίνει σε pause() mode και περιμένει τον JobCommander να του στείλει σήμα
οτι έστειλε κάτι στο pipe. Όταν λάβει το σήμα ξεκινάει και διαβάζει απο το pipe. Όταν τερματίσει διαγράφει το άρχειο που
δημιούργησε,διαγράφει χρησιμοποιημένη μνήμη και τερμάτιζει. Αν ο jobCommander στείλει την εντολή issueJob, δημιουργείται
η τριπλέτα της και προστίθεται στην ουρά αναμονής. Αν το Concurrency του προγράμματος το επιτρέψει τότε θα τρέξει η
διεργασία με fork() και exec(). Αν δωθεί η εντολή setConcurrency τότε η τιμή του Concurrency αλλάζει και αμέσως τρέχουν
διεργασίες που υπάρχουν στην ουρά αναμονής (queue_waiting) αν υπάρχουν ωστε ο αριθμός των διεργασιών που τρέχουν να
ισοβαθμίστουν με την τιμή του Concurrency. Αν η εντολή που θα στείλει ο JobCommander είναι η stop Job_XX τότε ελέγχεται
με την συνάρτηση της ουράς is_inside αρχικά αν βρισκέται στην ουρά queue_waiting. Αν βρίσκεται σε αυτή τότε αφαιρείται
και επιστρέφεται στον jobCommander job_XX removed. Αν όμως βρίσκεται στην ουρά queue_running τότε παίρνουμε το proccess
id της διεργασίας το οποίο βρίσκεται μέσα στην τριπλέτα και στέλνουμε σήμα για να σταματήσει. Αφαιρείται απο την ουρά
queue_running και επιστρέφεται στον jobCommander job_XX terminated.Τέλος αν η εντολή που θα περαστεί στον
JobExecutorServer είναι poll [queued\running], τότε χρησιμοποιούμε την συνάρτηση της ουράς που μας επιστρέφει όλες της
τριπλέτες της ουράς σε ένα array. Μέτα με τη βοήθεια αυτού του array χτίζονται όλες οι τριπλέτες στη μορφή 
<jobID,job,queuePosition>\n και επιστρέφονται στον jobCommander για να τις εκτυπώσει. 
    Κάθε φορά που τελειώνει μία διεργασία παιδί επιστρέφεται στον JobExecutorServer που την δημιούργησε ένα σημα SIGCHLD,
εκείνος το παίρνει αυτό το σήμα και το επεξεργάζεται με έναν handler. Μέσα στον handler άλλαζει το flag childend σε 1.
Μέσα στο while loop που αναφέρθηκε πριν γίνεται έλεγχος και αν το childend είναι 1 τότε αφαιρείται απο την
queue_running η διεργασία(παιρνουμε το pid μέσω της waitpid,με αυτό τον τρόπο επίσης η διεργασία σταματάει να είναι defunct),
αν δεν έχει ήδη αφαιρεθεί απο την εντολή stop(το ελέγχουμε με την μεταβλητή alrem), και τότε εισέγεται η επόμενη 
διεργασία στην queue_running αν υπάρχει στην queue_waiting.
